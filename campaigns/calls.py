import re
import os
import json
import time
import logging
import pandas as pd
import streamlit as st
from twilio.rest import Client
from datetime import datetime
from core.call_script_generator import generate_call_script

logger = logging.getLogger(__name__)


def _create_call_twiml(greeting: str, feedback_question: str) -> str:
    """
    Create TwiML for call with greeting, feedback question, recording, and transcription.
    Twilio will transcribe the recording automatically via API.
    """
    # Escape XML special characters in text
    def escape_xml(text):
        return (text.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;").replace("'", "&apos;"))
    
    greeting_escaped = escape_xml(greeting)
    question_escaped = escape_xml(feedback_question)
    
    # Build TwiML with Say and Record (transcription happens automatically via Twilio API)
    twiml = f'''<Response>
    <Say voice="alice">{greeting_escaped}</Say>
    <Pause length="2"/>
    <Say voice="alice">{question_escaped}</Say>
    <Pause length="1"/>
    <Say voice="alice">Please share your feedback after the beep. You have up to 30 seconds.</Say>
    <Record maxLength="30" transcribe="true" />
    <Say voice="alice">Thank you for your valuable feedback. Have a wonderful day!</Say>
</Response>'''
    return twiml


def _detect_name_column(df):
    """
    Auto-detect customer name column from common column names.
    Returns the first matching column name or None.
    """
    common_name_columns = [
        "CustomerName", "Name", "Customer Name", "FullName", "Full Name",
        "ContactName", "Contact Name", "ClientName", "Client Name",
        "FirstName", "First Name", "LastName", "Last Name"
    ]
    for col in common_name_columns:
        if col in df.columns:
            logger.info(f"âœ… Auto-detected name column: {col}")
            return col
    logger.info("â„¹ï¸ No name column detected, personalization will be limited")
    return None


def send_call_campaign(targets_df, phone_col, name_col=None, model=None):
    """
    Send LLM-powered call campaign with recording and transcription.
    Each call uses a personalized script generated by LLM.
    """
    try:
        account_sid = os.getenv("TWILIO_ACCOUNT_SID")
        auth_token = os.getenv("TWILIO_AUTH_TOKEN")
        from_phone = os.getenv("TWILIO_PHONE_NUMBER")
        if not all([account_sid, auth_token, from_phone]):
            logger.error("âŒ Missing Twilio credentials in .env file")
            return {"success": False, "sent": 0, "failed": 0, "error": "Missing Twilio credentials"}
        
        if not model:
            logger.warning("âš ï¸ No LLM model provided, using default script")
        
        client = Client(account_sid, auth_token)
        sent_count, failed_count = 0, 0
        failed_details = []
        call_details = []
        
        for _, row in targets_df.iterrows():
            try:
                phone = str(row.get(phone_col, "")).strip().replace(" ", "").replace("-", "")
                if phone.startswith("+91"):
                    phone = phone[3:]
                if not re.fullmatch(r"\d{10}", phone):
                    failed_count += 1
                    failed_details.append(f"Invalid phone: {phone}")
                    continue
                
                # Get customer data for personalization
                customer_name = str(row.get(name_col, "")).strip() if name_col and name_col in row else None
                customer_data = row.to_dict() if name_col else None
                
                # Generate LLM call script
                script = generate_call_script(customer_name, customer_data, model)
                logger.info(f"ðŸ“ Generated script for {phone}: {script.get('full_script', 'N/A')[:50]}...")
                
                # Create TwiML with recording and transcription
                twiml = _create_call_twiml(
                    script["greeting"],
                    script["feedback_question"]
                )
                
                # Place call with recording and transcription enabled (transcription via API)
                call = client.calls.create(
                    twiml=twiml,
                    to=f"+91{phone}",
                    from_=from_phone,
                    record=True  # Enable call recording (transcription handled automatically)
                )
                
                logger.info(f"ðŸ“ž Call placed to +91{phone} (SID: {call.sid})")
                call_details.append({
                    "phone": f"+91{phone}",
                    "sid": call.sid,
                    "status": call.status,
                    "script": script["full_script"],
                    "greeting": script["greeting"],
                    "feedback_question": script["feedback_question"]
                })
                sent_count += 1
            except Exception as e:
                failed_count += 1
                failed_details.append(f"{phone}: {e}")
                logger.error(f"âŒ Failed to call {phone}: {e}")
        
        result = {
            "success": True,
            "sent": sent_count,
            "failed": failed_count,
            "details": failed_details[:10],
            "call_details": call_details
        }
        logger.info(f"âœ… Call campaign completed: {sent_count} sent, {failed_count} failed")
        return result
    except Exception as e:
        logger.critical(f"âŒ Call campaign failed: {e}")
        return {"success": False, "sent": 0, "failed": len(targets_df), "error": str(e)}


def fetch_transcripts_from_twilio(call_sids: list = None, limit: int = 20):
    """
    Fetch transcripts directly from Twilio API (no webhook needed).
    Can fetch by specific call SIDs or get recent transcripts.
    """
    try:
        account_sid = os.getenv("TWILIO_ACCOUNT_SID")
        auth_token = os.getenv("TWILIO_AUTH_TOKEN")
        if not account_sid or not auth_token:
            logger.error("âŒ Missing Twilio credentials for fetching transcripts")
            return []
        
        client = Client(account_sid, auth_token)
        transcripts = []
        
        if call_sids:
            # Fetch transcripts for specific call SIDs
            logger.info(f"ðŸ” Fetching transcripts for {len(call_sids)} call SIDs...")
            for call_sid in call_sids:
                try:
                    call = client.calls(call_sid).fetch()
                    logger.info(f"ðŸ“ž Processing call {call_sid} (Status: {call.status})")
                    
                    # Get recordings for this call
                    recordings = client.calls(call_sid).recordings.list()
                    logger.info(f"ðŸ“¼ Found {len(recordings)} recording(s) for call {call_sid}")
                    
                    for recording in recordings:
                        try:
                            # Fetch transcriptions for this specific recording
                            # Twilio stores transcriptions linked to recordings
                            trans_list = client.recordings(recording.sid).transcriptions.list()
                            
                            if not trans_list:
                                # Try fetching all transcriptions and match by recording_sid
                                logger.info(f"âš ï¸ No transcriptions directly linked, searching all transcriptions...")
                                all_transcriptions = client.transcriptions.list(limit=100)
                                trans_list = [t for t in all_transcriptions if hasattr(t, 'recording_sid') and t.recording_sid == recording.sid]
                            
                            for trans in trans_list:
                                if trans.status == "completed":
                                    # Get transcription text
                                    try:
                                        trans_text = trans.transcription_text or ""
                                        if not trans_text and hasattr(trans, 'fetch'):
                                            trans_full = trans.fetch()
                                            trans_text = trans_full.transcription_text or ""
                                    except Exception as e:
                                        logger.warning(f"Could not get transcription text: {e}")
                                        trans_text = ""
                                    
                                    recording_url = f"https://api.twilio.com{recording.uri.replace('.json', '.mp3')}"
                                    
                                    # Get date
                                    try:
                                        date_created = getattr(recording, 'date_created', None) or getattr(trans, 'date_created', None)
                                        if date_created:
                                            date_str = date_created.isoformat() if hasattr(date_created, 'isoformat') else str(date_created)
                                        else:
                                            date_str = datetime.now().isoformat()
                                    except:
                                        date_str = datetime.now().isoformat()
                                    
                                    transcript_data = {
                                        "timestamp": date_str,
                                        "call_sid": call_sid,
                                        "transcription_sid": trans.sid,
                                        "recording_sid": recording.sid,
                                        "recording_url": recording_url,
                                        "transcript": trans_text,
                                        "phone": getattr(call, 'to_formatted', None) or str(getattr(call, 'to', 'Unknown')),
                                        "status": trans.status,
                                        "language": getattr(trans, 'language', 'en-US'),
                                        "duration": str(call.duration) if hasattr(call, 'duration') and call.duration else ""
                                    }
                                    transcripts.append(transcript_data)
                                    logger.info(f"âœ… Found completed transcript for call {call_sid}, recording {recording.sid}")
                                else:
                                    logger.info(f"â³ Transcription {trans.sid} status: {trans.status}")
                        except Exception as rec_e:
                            logger.warning(f"Error processing recording {recording.sid}: {rec_e}")
                except Exception as e:
                    logger.warning(f"Could not fetch transcript for call {call_sid}: {e}", exc_info=True)
        else:
            # Fetch recent transcriptions (all completed ones)
            logger.info(f"ðŸ” Fetching recent transcriptions (limit: {limit})...")
            try:
                all_transcriptions = client.transcriptions.list(limit=limit * 2)  # Get more to filter
                logger.info(f"ðŸ“‹ Found {len(all_transcriptions)} total transcriptions")
                
                for trans in all_transcriptions:
                    if trans.status == "completed":
                        # Try to get call info from recording
                        call_sid = "Unknown"
                        phone = "Unknown"
                        duration = ""
                        recording_url = None
                        
                        recording_sid = getattr(trans, 'recording_sid', None)
                        if recording_sid:
                            try:
                                recording = client.recordings(recording_sid).fetch()
                                call_sid = getattr(recording, 'call_sid', 'Unknown')
                                recording_url = f"https://api.twilio.com{recording.uri.replace('.json', '.mp3')}"
                                
                                if call_sid != "Unknown":
                                    try:
                                        call = client.calls(call_sid).fetch()
                                        phone = getattr(call, 'to_formatted', None) or str(getattr(call, 'to', 'Unknown'))
                                        duration = str(call.duration) if hasattr(call, 'duration') and call.duration else ""
                                    except Exception as call_e:
                                        logger.debug(f"Could not fetch call info: {call_e}")
                            except Exception as rec_e:
                                logger.debug(f"Could not fetch recording info: {rec_e}")
                        
                        # Get transcription text
                        try:
                            trans_text = getattr(trans, 'transcription_text', None) or ""
                            if not trans_text:
                                trans_full = trans.fetch()
                                trans_text = getattr(trans_full, 'transcription_text', None) or ""
                        except Exception as e:
                            logger.debug(f"Could not get transcription text: {e}")
                            trans_text = ""
                        
                        # Parse date
                        try:
                            date_created = getattr(trans, 'date_created', None)
                            if date_created:
                                date_str = date_created.isoformat() if hasattr(date_created, 'isoformat') else str(date_created)
                            else:
                                date_str = datetime.now().isoformat()
                        except:
                            date_str = datetime.now().isoformat()
                        
                        transcript_data = {
                            "timestamp": date_str,
                            "call_sid": call_sid,
                            "transcription_sid": trans.sid,
                            "recording_sid": recording_sid,
                            "recording_url": recording_url,
                            "transcript": trans_text,
                            "phone": phone,
                            "status": trans.status,
                            "language": getattr(trans, 'language', 'en-US'),
                            "duration": duration
                        }
                        transcripts.append(transcript_data)
                        logger.info(f"âœ… Added transcript {trans.sid} for call {call_sid}")
                        
                        # Limit results
                        if len(transcripts) >= limit:
                            break
            except Exception as e:
                logger.error(f"Error fetching recent transcriptions: {e}", exc_info=True)
        
        logger.info(f"âœ… Fetched {len(transcripts)} transcripts from Twilio API")
        return transcripts
    except Exception as e:
        logger.error(f"âŒ Error fetching transcripts from Twilio: {e}", exc_info=True)
        return []


def render_call_campaign(df, model):
    with st.container():
        st.markdown("### ðŸ“ž LLM-Powered Customer Feedback Call Campaign")
        st.info("ðŸ¤– This campaign uses AI to generate personalized greetings and feedback questions. Calls are recorded and transcribed via Twilio API.")
        st.success("âœ… Transcripts will be fetched directly from Twilio API - no setup needed!")
        
        st.markdown("#### ðŸŽ¯ Select Target Customers")
        target_query = st.text_input("Enter Targeting Condition (natural language)", placeholder="e.g., customers named 'Rahul' with PhoneNo present", key="call_target")
        phone_col = "PhoneNo"
        col1, col2 = st.columns([1, 1])
        with col1:
            if st.button("ðŸ” Preview Customers (DB)", key="call_preview_btn", width='stretch'):
                if not target_query:
                    st.warning("âš ï¸ Please enter a targeting condition.")
                    return
                try:
                    from db.turso import (
                        get_turso_client,
                        get_table_schema_sql,
                        generate_select_sql_from_prompt,
                        execute_select,
                        close_client,
                    )
                    client = get_turso_client()
                    if not client:
                        st.error("DB client unavailable")
                        return
                    table_name = st.session_state.get("turso_table")
                    if not table_name:
                        st.error("No synced table. Upload and sync data first.")
                        close_client(client)
                        return
                    schema_sql = get_table_schema_sql(client, table_name)
                    if not schema_sql:
                        st.error("Table schema not found.")
                        close_client(client)
                        return
                    enriched_prompt = f"{target_query}. Return `{phone_col}` column if relevant."
                    sql = generate_select_sql_from_prompt(enriched_prompt, table_name, schema_sql, model)
                    rows, columns = execute_select(client, sql)
                    close_client(client)
                    if not rows:
                        st.info("No matching customers.")
                        return
                    result_df = pd.DataFrame(rows, columns=columns if columns else None)
                    if phone_col not in result_df.columns:
                        st.error("Results missing required column: PhoneNo")
                        return
                    st.session_state.call_targets = result_df
                    st.success(f"âœ… Found {len(result_df)} target customers.")
                    with st.expander("ðŸ“‹ View Target List"):
                        st.dataframe(result_df[[phone_col]].head(20), width='stretch')
                except Exception as e:
                    st.error(f"âŒ Query Error: {e}")
        with col2:
            if st.button("ðŸ“ž Start Reminder Calls", type="primary", key="call_send_btn", width='stretch'):
                if "call_targets" not in st.session_state:
                    st.warning("âš ï¸ Please preview the target customers first.")
                    return
                
                with st.spinner("ðŸ“ž Placing AI-powered calls with recording... Please wait â³"):
                    logger.info("ðŸ“ž Starting LLM-powered call campaign with transcription")
                    # Auto-detect name column in background
                    auto_name_col = _detect_name_column(st.session_state.call_targets)
                    result = send_call_campaign(
                        st.session_state.call_targets,
                        phone_col,
                        name_col=auto_name_col,
                        model=model
                    )
                    if result["success"]:
                        st.success(f"âœ… Calls successfully placed to {result['sent']} customers.")
                        
                        # Store call SIDs for later transcript fetching
                        if result.get("call_details"):
                            call_sids = [d["sid"] for d in result["call_details"]]
                            st.session_state.last_call_sids = call_sids
                            
                            # Show generated scripts preview
                            with st.expander("ðŸ“ View Generated Call Scripts"):
                                for detail in result["call_details"][:5]:
                                    st.markdown(f"**{detail['phone']}** (SID: `{detail['sid']}`)")
                                    st.text(f"Greeting: {detail['greeting']}")
                                    st.text(f"Question: {detail['feedback_question']}")
                                    st.divider()
                        
                        if result.get("failed", 0) > 0:
                            with st.expander("âš ï¸ Failed Calls"):
                                for d in result["details"]:
                                    st.text(d)
                        
                        if "campaign_logs" not in st.session_state:
                            st.session_state.campaign_logs = []
                        st.session_state.campaign_logs.append({
                            "time": pd.Timestamp.now().strftime("%Y-%m-%d %H:%M:%S"),
                            "type": "Call (AI)",
                            "targets": len(st.session_state.call_targets),
                            "sent": result["sent"],
                            "failed": result["failed"],
                            "status": "âœ… Success",
                            "query": target_query
                        })
                        
                        st.info("ðŸ’¡ Use the 'Fetch Transcripts' button below to retrieve transcripts after calls complete (wait 1-2 minutes for transcription).")
                    else:
                        st.error(f"âŒ Call campaign failed: {result.get('error', 'Unknown error')}")
        
        # Fetch transcripts buttons
        st.markdown("---")
        st.markdown("#### ðŸ“‹ Fetch Call Transcripts")
        col_fetch1, col_fetch2 = st.columns([1, 1])
        with col_fetch1:
            if st.button("ðŸ”„ Fetch Recent Transcripts", key="fetch_transcripts_btn"):
                with st.spinner("â³ Fetching transcripts from Twilio API..."):
                    # Wait a bit for transcriptions to process
                    time.sleep(2)
                    try:
                        transcripts = fetch_transcripts_from_twilio(limit=20)
                        if transcripts:
                            if "call_transcripts" not in st.session_state:
                                st.session_state.call_transcripts = []
                            st.session_state.call_transcripts.extend(transcripts)
                            st.success(f"âœ… Fetched {len(transcripts)} transcript(s)!")
                        else:
                            st.warning("âš ï¸ No transcripts found. Possible reasons:\n- Calls haven't completed yet (wait 1-2 minutes)\n- Transcription is still processing\n- No calls were recorded\n\nCheck the logs for more details.")
                    except Exception as e:
                        st.error(f"âŒ Error fetching transcripts: {str(e)}")
                        logger.error(f"Error in UI fetch: {e}", exc_info=True)
        
        with col_fetch2:
            if st.button("ðŸ”„ Fetch Transcripts for Last Campaign", key="fetch_last_campaign_btn"):
                if "last_call_sids" in st.session_state and st.session_state.last_call_sids:
                    with st.spinner("â³ Fetching transcripts for last campaign calls..."):
                        time.sleep(2)
                        try:
                            transcripts = fetch_transcripts_from_twilio(call_sids=st.session_state.last_call_sids)
                            if transcripts:
                                if "call_transcripts" not in st.session_state:
                                    st.session_state.call_transcripts = []
                                st.session_state.call_transcripts.extend(transcripts)
                                st.success(f"âœ… Fetched {len(transcripts)} transcript(s) for last campaign!")
                            else:
                                st.warning(f"âš ï¸ No transcripts found for {len(st.session_state.last_call_sids)} call(s).\n- Transcription may still be processing (wait 1-2 minutes)\n- Check if recordings exist for these calls\n- Verify transcription is enabled in TwiML")
                        except Exception as e:
                            st.error(f"âŒ Error fetching transcripts: {str(e)}")
                            logger.error(f"Error in UI fetch for last campaign: {e}", exc_info=True)
                else:
                    st.warning("âš ï¸ No recent campaign calls found. Start a campaign first.")
        
        # Show stored transcripts if available
        if "call_transcripts" in st.session_state and st.session_state.call_transcripts:
            st.markdown("---")
            st.markdown("#### ðŸ“‹ Call Transcripts")
            # Deduplicate by transcription_sid
            seen = set()
            unique_transcripts = []
            for t in st.session_state.call_transcripts:
                sid = t.get("transcription_sid") or t.get("call_sid")
                if sid and sid not in seen:
                    seen.add(sid)
                    unique_transcripts.append(t)
            
            for transcript in unique_transcripts[-10:]:  # Show last 10
                phone_display = transcript.get('phone', 'Unknown')
                timestamp_display = transcript.get('timestamp', 'N/A')
                if isinstance(timestamp_display, str) and len(timestamp_display) > 19:
                    timestamp_display = timestamp_display[:19]
                with st.expander(f"ðŸ“ž {phone_display} - {timestamp_display}"):
                    if transcript.get("transcript"):
                        st.markdown(f"**Transcript:** {transcript['transcript']}")
                    st.json(transcript)


